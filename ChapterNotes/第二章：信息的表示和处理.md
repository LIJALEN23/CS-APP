# 信息的表示和处理
- **二值信号**：二进制数字，*位(bit)*
  - 二值信号容易被表示，储存和传输
  - 将位组合起来，再加上某种解释就有含义

- 三种最重要的数字表示
  - 无符号：基于传统的二进制表示法，可以表示 >= 0 的数字
  - 补码：表示有符号整数
  - 浮点数：表示实数的科学计数法的以2为基数的版本
- 问题
  - 溢出(overflow)：计算机以有限的位来表示一个数字的编码，当这个数字的编码太大了，会出现溢出的现象
  - 浮点数的表示是近似的，会损失精度

> C语言的演变的故事
## 信息储存
- 四个抽象概念
 - **最小可寻址的内存单位**：大多数计算机使用8个位的块或者字节(byte)，作为最小可寻址的内存单位
 - **虚拟内存**：机器级程序将内存视为一个非常大的 **字节数组**
 - **地址**：每个字节都有唯一一个数字来标识
 - **虚拟地址空间**：所有可能地址的集合
- 将储存器划分为可管理单元，用来存放不同的 *程序对象*
  - 数据
  - 指令
  - 控制信息

### 十六进制表示法
- 十六进制(hexadecimal)：‘0’ ~ ‘9’ + ‘A(a)’ ~ ‘F(f)’
- 在C语言中以 0x/0X 开头的数字常量被认为是十六进制的值。
- 编写机器级程序有一个常见的任务就是在位模式下，手工转换十进制，二进制，十六进制

### 字数据大小
对于程序员写出可移植程序非常重要。
- 每个计算机都有一个**字长(word size)**，来指明指针数据的**标称大小(nominal size)**。
  - 对于一个w位字长的机器，虚拟地址的范围为：0 ~ 2^w-1 ，程序最多访问2^w 个字节。
- 32位字长的虚拟地址空间为4GB，64位字长的虚拟地址空间为16GB。
近些年，计算机都从32位的字长向64位字长迁移。64位可以运行32位编译的程序，向后兼容。
- 由机器位数不同带来的差异
  - C语言中的典型数据的差异：
  ![](../Pictures/C语言中数据类型的差距.png)
- 解决差异：
  - ISO C99引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。例如int32_t(4个字节), int64_t(8个字节)
### 寻址和字节顺序
一个w位的整数，其位表示为[Xw-1, Xw-2,.....X0]，其中Xw-1是最高有效位，X0是最低有效位
- 储存顺序：
  - 小端法：最低有效位在最前面
  - 大端法：最高有效位在最前面(常规认识下的方式)

由于储存顺序是不可见的，但是在一些情况下却不能忽视
1. 网络传输二进制数据时：在不同储存方式的机器间可能会导致数据倒过来的情况。
2. 阅读表示整数数据的字节序列时字节顺序也很重要。通常发生在机器级程序时。
3. 编写规避正常的类型系统的程序
### 表示字符串
- C语言中字符串是一个以'\0'结束的字符数组。通过不同的编码标准表示不同字符
- 文本数据比二进制有更强的平台独立性
> 文本编码：ASCII和Unicode
### 表示代码
- 二进制代码很少能在不同的机器上和操作系统间移植
### 布尔代数简介
因为二进制是计算机编码，储存和操作信息的核心。所以围绕0和1的研究已经演化成了非常丰富的数学知识体系
- ~(NOT)
- &(AND)
- |(OR)
- ^(XOR)

*位向量*：在应用中的例子，指定一个位向量*掩码*.......

### C语言的位级运算
一个简单的例子：
```C
/*通过布尔代数运算，该函数可以实现将两个指针指向的两个值互换*/
void inplace_swap(int* x, int* y) {
  *x = *x ^ *y;
  *y = *x ^ *y;
  *x = *x ^ *y;
}
```

### C语言的逻辑运算
- ||(OR)
- &&(AND)
- !(NOT)

### C语言的位移运算
C语言提供的移位运算
- \>\>(算数左移，首位添加0)
- <<(算数右移，末尾添加0)

## 整数的表示
分为两大类：有符号数和无符号数
- 无符号数：可以表示非负整数(正常储存)
- 有符号数：可以表示负整数，零，正整数(补码储存)
当进行不当操作时，会引起一些溢出等问题
### 整数数据类型
- 在32位和64位的系统中对一些整数分配的字节大小会有差别：例如long类型，32中分配4个字节，64中分配8个字节(C99中增加了<stdint.h>来固定一个定长的数据类型，不管在哪种系统中，字节大小一样)

### 无符号数的编码
无符号数编码具有唯一性
### 补码编码
为了表示和储存有符号数，引入了反码和补码(第一位是符号位，0-整数，1-负数)
- 正整数：原码，反码，补码相同
- 负整数：原码，反码(符号位不变，其他位取反)，补码(符号位不变，加1并按相应进位操作)
注意在底层中是怎样处理这两种整数的
### 有符号数和无符号数的转换
没看懂。以我的理解就是复杂数学运算。但是理解起来就是相当于进行了一些操作加符号位什么的
- 强制类型转化的结果是保持位不变，知识改变了解释这些位的解释方式。

### C语言中的有无符号数
- C标准没有精确规定应如何进行这种转换，但大多数系统遵循的原则是底层的位表示保持不变

### 扩展一个数字的位表示
零扩展：将一个无符号数转化为一个更大的数据类型，在表示的开头添加0
- 原理：
  - 无符号数
  - 补码数
  
### 截断数字
不额外增加一个位，而是减少表示一个数字的位数
- 原理：
  - 截断补码数值
  - 截断无符号数
### 关于有符号数和无符号数的建议
- 隐式的强制转换类型导致一些非直观的行为，会导致程序错误，程序员经常忽视它们(所以显式的强制类型转化更科学)。
- **无符号数到有符号数的隐式转化，会导致错误和漏洞。避免这类错误的方法就是绝对不使用无符号数**

## 整数的运算
我们在敲代码的时候会发现，有时候两个正数相加会得到一个负数。这是由于计算机运算的特性决定的。
### 无符号加法
- 两个比较大的无符号整数相加时，有可能会得到一个超出字长的值，造成溢出
- 可以实现一个函数来检测是否造成溢出
### 补码加法
- 两个有符号整数运算时，结果有可能太小造成负溢出或者太大造成正溢出
### 补码的非
没看懂
### 无符号乘法和补码乘法
没看懂
### 乘以常数
- 对于乘法的运算会消耗大量的资源，而与2相乘时可以通过左移操作符实现
### 除以2的幂
- 处理除法运算会更慢，所以可以通过右移操作符来实现
### 关于整数运算
- 计算机执行的整数运算实际上是哟中模运算形式

## 浮点数
IEEE标准与舍入问题
### 二进制小数
- 只能表示被写成x*2^y的数，其他的只能进行近似的表示。
### IEEE浮点表示
- IEEE浮点标准：V = (-1)^s * M * 2^E 的形式来表示一个数
  - 符号(sign)：0-正数，1-负数
  - 尾数(significand)：M是一个二进制小数(1 ~ 2-x 或者0 ~ 1-x)
  - 阶码(exponent)：E的作用是对浮点数加权，这个权重是2的次幂

不太懂

### 舍入
由于表示方法限制了浮点数的精度和范围，所以浮点数运算只能近似地表示实数的运算。
- 舍入方式：一种系统的方法进行舍入以找到最接近匹配的值
  - 向偶数舍入(向最近的值舍入)
  - 向零舍入
  - 向下舍入
  - 向上舍入
### 浮点运算
IEEE标准指定了一个简单的规则来确定算数运算的结果。可以独立于任何具体的硬件和软件
### C语言中的浮点数
float单精度和double双精度

## 小结
- 计算机中将信息编码为位(bit)
- 64位字长的机器的出现
- 补码与IEEE标准754编码
- 强制类型转化的底层问题
- .......